= Regex


== Search and Replace on Files

Given a file a.txt containing:

  This is file a.txt.
  This is an example.

And given a file b.txt containing:

  This is file b.txt.
  This is another example.

Then invoking the command:

  $ regex -s example -r EXAMPLE a.txt b.txt

Should result in a new file a.txt containing:

  This is file a.txt.
  This is an EXAMPLE.

And should result in a new file b.txt containing:

  This is file b.txt.
  This is another EXAMPLE.


== Searching Files

Given a file a.txt containing:

  This is file a.txt.
  This is an example.

And given a file b.txt containing:

  This is file b.txt.
  This is another example.

Then invoking the command:

  $ regex -s example a.txt b.txt

Should produce:

  example

In this case it found the first match and returned it.
To handle a global search we add the `-g` flag.

Invoking the command:

  $ regex -g -s example a.txt b.txt

Will give a more complex result.

  @out.assert == "example\036\nexample\n"


== Regex class

Regex is really meant to be used on the command-line since
it is really nothing more than a front end to Ruby's regular
expression engine. But we will demonstrate it's use here in
code just the same, and to help ensure code quality.

First we need to require the Regex library.

  require 'regex'

Now let's create some material to work with.

  text = "We will match against this string."

Now we can then create a Regex object using the text.
We will also suppoly a matching pattern, as none of
the matching functions will work without providing
a pattern or the name of built-in pattern template.

  rx = Regex.new(text, :pattern=>'\w+')

We can see that the Regex object has converted the pattern
into the expected regular expression via the #regex method.

  rx.regex.assert == /\w+/

Under the hood, Regex has split the process of matching,
organizing and formating the results into separate methods.
We can use the #structure method to see thematch results
organized into uniform arrays.

  rx.structure.assert == %w{We}

Whereas the last use only returns a single metch, if we turn
on repeat mode we can see every word.

  rx.repeat = true

  rx.structure.assert == %w{We will match against this string}.map{ |e| [e] }

Notice that repeat mode creates an array in an array.


== Regex::Replacer

Regex can also be used to do search and replace across multiple
strings or IO objects, includeing files.

  require 'regex'

To perform search and replace procedure we create a Regex::Replacer object.
The constructor method takes a Hash of options which set universal parameters
to apply to all search and replace rules. Usually, each individual rule
will specify it's own options, so for this example we provide none.

  replacer = Regex::Replacer.new

Rules are added via the #rule method.

  replacer.rule('World', 'Planet Earth')
  replacer.rule('!', '!!!')

Rules are applied in the order they were defined. If there rules overlap
in their effects this can be signifficant.

Now, lets say we have that famous String,

  string = "Hello, World!"

We use the #apply method to actually perform the substitutions.

  replacer.apply(string)

The replacements occur in place. Since in this case we are performing
the serach and replace on a String object, we can see the change 
has taken place.

  string.assert == "Hello, Planet Earth!!!"

As we mentioned at the beginning, substitutions can be applied to IO
objects in general, so long as they they can be reopended for writing.

  require 'stringio'

  io = StringIO.new("Hello, World!")

  replacer.apply(io)

  io.read.assert == "Hello, Planet Earth!!!"

If +io+ were a File object, rather than a StringIO, the file would
be changed on disk. As a precaution a backup file can be written 
with the name of file plus a '.bak' extension in the same directory as
the file. To turn on the backup option, either supply it as an option
to the constructor, or set it via the writer method.

  replacer.backup = true

(TODO: Example of a file search and replace.)


